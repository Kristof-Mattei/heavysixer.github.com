<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Mark Daggett's Blog]]></title>
  <link href="http://heavysixer.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://heavysixer.github.com/"/>
  <updated>2012-04-14T20:24:36-05:00</updated>
  <id>http://heavysixer.github.com/</id>
  <author>
    <name><![CDATA[Mark Daggett]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[client-side request caching with Javascript]]></title>
    <link href="http://heavysixer.github.com/blog/2012/03/28/client-side-request-caching-with-javascript/"/>
    <updated>2012-03-28T20:30:00-05:00</updated>
    <id>http://heavysixer.github.com/blog/2012/03/28/client-side-request-caching-with-javascript</id>
    <content type="html"><![CDATA[<p>Recently I was writing an enterprise data visualization application that made heavy user of interactive charts and graphs. Like most best-of-breed data-viz apps this one supported very robust filters for slicing and dicing through the dataset. Each time the user adjusted one of these filters the application made new AJAX request and idled until the results were returned.</p>

<p>Technically, this approach worked fine, but because the data-segmentation occurred on the server the charts felt sluggish because they were always polling or data. Additionally, the user quite frequently toggled between only a couple filters to compare the results. What should have been an experience of rapidly flipping between two views on the data was actually a belabored rendering experience. As the developer this was frustrating because they were asking for and receiving the same data over and over again.</p>

<p>To solve this problem, I built a very simple mechanism that affords <em>just enough caching</em> to persist these payload objects only while the user is viewing the page. In this way the user would be guaranteed to get a fresh copy from the server on each page load.</p>

<p>Essentially, I hooked my caching routine around the function that made the AJAX request for new chart data. Using this approach an AJAX request only occurred once, and all future requests pulled from the cache.</p>

<p>``` javascript
// Called when someone adjusts a filter
function updateChart(url, chart, key) {</p>

<pre><code>// Builds the request params needed to correctly query the server. 
var opts = requestParamsFor(chart, key);

// Generate a cache key based on this object
var cacheKey = $.cache.getKey(opts);

if ($.hh.cache.exists(cacheKey)) {

    // If the key exists then the request has happened in the past
    // use the cached result to refresh the chart.
    var result = $.cache.get(cacheKey);
    onSuccess(kind, opts, chart, code, result);
} else {
    $.ajax({
        url: url,
        type: 'POST',
        data: opts,
        success: function(result) {

            // Since this was a new request store the results in the cache 
            // at the location specified by the cache key.
            $.cache.add(cacheKey, result);
            onSuccess(kind, opts, chart, code, result);
        }
    });
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Here is the local cache class in all it's detail:</p>

<p>``` javascript
$.cache = (function() {</p>

<pre><code>var _cache = {};
var _keys = [];
var _indexOf = function(arr, obj) {
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) {
        if (arr[i] == obj) {
            return i;
        }
    }
    return - 1;
};
var _serialize = function(opts) {
    if ((opts).toString() === "[object Object]") {
        return $.param(opts);
    } else {
        return (opts).toString();
    }
};
var _remove = function(key) {
    var t;
    if ((t = _indexOf(_keys, key)) &gt; -1) {
        _keys.splice(t, 1);
        delete _cache[key];
    }
};
var _removeAll = function() {
    _cache = {};
    _keys = [];
};
var add = function(key, obj) {
    if (_keys.indexOf(key) === -1) {
        _keys.push(key);
    }
    _cache[key] = obj;
    return $.hh.cache.get(key);
};
var exists = function(key) {
    return _cache.hasOwnProperty(key);
};
var purge = function() {
    if (arguments.length &gt; 0) {
        _remove(arguments[0]);
    } else {
        _removeAll();
    }
    return $.extend(true, {},
    _cache);
};
var searchKeys = function(str) {
    var keys = [];
    var rStr;
    rStr = new RegExp('\\b' + str + '\\b', 'i');
    $.each(_keys,
    function(i, e) {
        if (e.match(rStr)) {
            keys.push(e);
        }
    });
    return keys;
};
var get = function(key) {
    var val;
    if (_cache[key] !== undefined) {
        if ((_cache[key]).toString() === "[object Object]") {
            val = $.extend(true, {},
            _cache[key]);
        } else {
            val = _cache[key];
        }
    }
    return val;
};
var getKey = function(opts) {
    return _serialize(opts);
};
var getKeys = function() {
    return _keys;
};
return {
    add: add,
    exists: exists,
    purge: purge,
    searchKeys: searchKeys,
    get: get,
    getKey: getKey,
    getKeys: getKeys
};
</code></pre>

<p>}).call(this);
```</p>

<p>Here are some jasmine tests which explain more features of the cache not covered in this post, and prove that it works!</p>

<p>``` javascript
it("should allow you to build a cache using keys",
function() {</p>

<pre><code>var obj = {
    'foo': 'bar'
};
expect($.cache.exists("foo=bar")).toEqual(false);
expect($.cache.getKey(obj)).toEqual('foo=bar');
expect($.cache.getKey('foo')).toEqual('foo');
expect($.cache.add("foo=bar", obj)).toEqual(obj);
expect($.cache.exists("foo=bar")).toEqual(true);
expect($.cache.get("foo=bar")).toEqual(obj);
expect($.cache.get("bar")).toEqual(undefined);
</code></pre>

<p>});</p>

<p>it("should allow you to empty the cache completely",
function() {</p>

<pre><code>$.cache.purge();
expect($.cache.add("baz", 'baz')).toEqual('baz');
expect($.cache.getKeys().length).toEqual(1);
expect($.cache.purge()).toEqual({});
</code></pre>

<p>});</p>

<p>it("should allow you to empty the cache of just a specific record",
function() {</p>

<pre><code>$.cache.purge();
expect($.cache.add("baz", 'baz')).toEqual('baz');
expect($.cache.add("boff", 'ball')).toEqual('ball');
expect($.cache.getKeys()).toEqual(['baz', 'boff']);
expect($.cache.purge('boff')).toEqual({
    'baz': 'baz'
});
expect($.cache.getKeys()).toEqual(['baz']);
expect($.cache.purge('bozz')).toEqual({
    'baz': 'baz'
});
expect($.cache.getKeys()).toEqual(['baz']);
</code></pre>

<p>});</p>

<p>it("should allow you to search for keys in the cache",
function() {</p>

<pre><code>$.cache.purge();
var obj = {
    'bar': 'baz'
};
$.cache.add('bar=baz', obj);
expect($.cache.getKeys().length).toEqual(1);
expect($.cache.getKeys()).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bar")).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bar=")).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bat")).toEqual([]);
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Beautiful Gradients Using Javascript]]></title>
    <link href="http://heavysixer.github.com/blog/2012/03/23/generate-beautiful-gradients-using-javascript/"/>
    <updated>2012-03-23T10:34:00-05:00</updated>
    <id>http://heavysixer.github.com/blog/2012/03/23/generate-beautiful-gradients-using-javascript</id>
    <content type="html"><![CDATA[<p>I use Highcharts an excellent charting library built in Javascript for much of my data visualization and analytic work. However, one thing that has always bugged me is their collection of default series colors, which are a bit limp. Highcharts does provide an easy way to manually override their defaults with your own list of colors. Unfortunately, it's not always possible to know in advance how many series will be supplied to the chart object. In the cases where there are more series than there are manually supplied colors the Highcharts default colors will start to leak into your charts and ruin the visual aesthetics. I wrote the gradient generator to produce a range of colors based on the parameters you supply. You simply supply start and stop colors and the number of steps in between, and you'll be sure to have enough colors for your series.</p>

<p>Even though I made this generator for a need I had in highcharts, you can use it anywhere you want a uniform sequence of colors. Here is how I use it in Highcharts:</p>

<p>``` javascript
var seriesColors = gradientFactory.generate({</p>

<pre><code>from: "#0000FF",
to: ""#FF0000"
stops: chartConfig.series.length
</code></pre>

<p>})
$.each(chartConfig.series,
function(i, v) {</p>

<pre><code>seriesOptions.push({
    color: seriesColors[i]
    // other attributes ...
});
</code></pre>

<p>});
```</p>

<p>Here is the code for the Gradient Factory:</p>

<p>``` javascript
gradientFactory = (function() {</p>

<pre><code>var _beginColor = {
    red: 0,
    green: 0,
    blue: 0
};
var _endColor = {
    red: 255,
    green: 255,
    blue: 255
};
var _colorStops = 24;
var _colors = [];
var _colorKeys = ['red', 'green', 'blue'];
var _rgbToHex = function(r, g, b) {
    return '#' + _byteToHex(r) + _byteToHex(g) + _byteToHex(b);
};
var _byteToHex = function(n) {
    var hexVals = "0123456789ABCDEF";
    return String(hexVals.substr((n &gt;&gt; 4) &amp; 0x0F, 1)) + hexVals.substr(n &amp; 0x0F, 1);
};
var _parseColor = function(color) {
    if ((color).toString() === "[object Object]") {
        return color;
    } else {
        color = (color.charAt(0) == "#") ? color.substring(1, 7) : color;
        return {
            red: parseInt((color).substring(0, 2), 16),
            green: parseInt((color).substring(2, 4), 16),
            blue: parseInt((color).substring(4, 6), 16)
        };
    }
};
var _generate = function(opts) {
    var _colors = [];
    var options = opts || {};
    var diff = {
        red: 0,
        green: 0,
        blue: 0
    };
    var len = _colorKeys.length;
    var pOffset = 0;
    if (typeof(options.from) !== 'undefined') {
        _beginColor = _parseColor(options.from);
    }
    if (typeof(options.to) !== 'undefined') {
        _endColor = _parseColor(options.to);
    }
    if (typeof(options.stops) !== 'undefined') {
        _colorStops = options.stops;
    }
    _colorStops = Math.max(1, _colorStops - 1);
    for (var x = 0; x &lt; _colorStops; x++) {
        pOffset = parseFloat(x, 10) / _colorStops;
        for (var y = 0; y &lt; len; y++) {
            diff[_colorKeys[y]] = _endColor[_colorKeys[y]] - _beginColor[_colorKeys[y]];
            diff[_colorKeys[y]] = (diff[_colorKeys[y]] * pOffset) + _beginColor[_colorKeys[y]];
        }
        _colors.push(_rgbToHex(diff.red, diff.green, diff.blue));
    }
    _colors.push(_rgbToHex(_endColor.red, _endColor.green, _endColor.blue));
    return _colors;
};
return {
    generate: _generate
};
</code></pre>

<p>}).call(this);
```</p>

<p>Here are a few Jasmine Specs to prove it works:</p>

<p>``` javascript
describe("Gradient Generator",
function() {
  it("should generate a series of gradient colors",
  function() {</p>

<pre><code>  expect($.hh.plugins.gradientFactory.generate({
      from: '#aed0ee',
      to: '#2a5980',
      stops: 2
  })).toEqual(['#AED0EE', '#2A5980']);
  expect($.hh.plugins.gradientFactory.generate({
      from: '#000000',
      to: '#999999',
      stops: 10
  })).toEqual(['#000000', '#111111', '#222222', '#333333', '#444444', '#555555', '#666666', '#777777', '#888888', '#999999']);
</code></pre>

<p>  });
});
```
A big tip of the hat to my friend jim bumgardner, who i <a href="http://krazydad.com/tutorials/makecolors.php">cribbed the color conversation functions from</a>.</p>
]]></content>
  </entry>
  
</feed>
