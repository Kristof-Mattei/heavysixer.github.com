<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Mark Daggett's Blog]]></title>
  <link href="http://heavysixer.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://heavysixer.github.com/"/>
  <updated>2013-03-01T09:29:52-06:00</updated>
  <id>http://heavysixer.github.com/</id>
  <author>
    <name><![CDATA[Mark Daggett]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[racing and profiling]]></title>
    <link href="http://heavysixer.github.com/blog/2013/03/01/racing-and-profiling/"/>
    <updated>2013-03-01T09:08:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/03/01/racing-and-profiling</id>
    <content type="html"><![CDATA[<p>I've been experimenting with various ways to profile, and explore JavaScript as it executes in the runtime environment. Mostly I've been
experimenting with the rKelly and rubyracer gems. Both gems are written by people much smarter than myself so there is lots to learn and
explore inside their source. I was talking to the very friendly <code>Charles Lowell &lt;https://twitter.com/cowboyd&gt;</code>_, creator of the rubyracer
and he shared this great snippet with me, which allows you to turn on the v8 profiler while the rubyracer is running. Because this is an
undocumented hook I thought I'd share it here:</p>

<p>.. code-block:: ruby</p>

<p>  ruby -Ilib -Iext -rv8 -e 'V8::C::V8::SetFlagsFromString("--prof"); V8::Context.new() {|c| puts c.eval("5 + 1")}; V8::C::V8::PauseProfiler()'</p>

<p>This will produce a <em>v8.log</em> file wherever you executed the script from. Inside the file there is a gluttonous amount of data, which will
take some time to parse through but in general it looks a bit like this:</p>

<p>::</p>

<p>  code-creation,LoadIC,0x127fc3e29140,181,"A load IC from the snapshot"
  code-creation,KeyedLoadIC,0x127fc3e29200,181,"A keyed load IC from the snapshot"
  code-creation,StoreIC,0x127fc3e292c0,183,"A store IC from the snapshot"
  code-creation,KeyedStoreIC,0x127fc3e29380,183,"A keyed store IC from the snapshot"
  code-creation,Builtin,0x127fc3e29440,97,"A builtin from the snapshot"
  code-creation,Builtin,0x127fc3e294c0,137,"A builtin from the snapshot"
  code-creation,Script,0x127fc3e14e20,980,"native string.js",0x2e87cc50ec50,
  code-creation,LazyCompile,0x127fc3e15500,1616,"SetUpString native string.js:940",0x2e87cc5129c8,
  code-creation,LazyCompile,0x127fc3e15be0,472," native string.js:36",0x2e87cc512ab0,
  code-creation,Script,0x127fc3e15dc0,336,"native array.js",0x2e87cc512e00,
  code-creation,LazyCompile,0x127fc3e15f20,2544,"SetUpArray native array.js:1469",0x2e87cc5175b0,
  code-creation,LazyCompile,0x127fc3e16920,340,"SetUpArray.b native array.js:1482",0x2e87cc517668,
  code-creation,Script,0x127fc3e16b00,552,"native regexp.js",0x2e87cc5177f0,
  code-creation,LazyCompile,0x127fc3e16d40,388,"RegExpConstructor native regexp.js:86",0x2e87cc518a70,
  code-creation,LazyCompile,0x127fc3e16ee0,280,"RegExpMakeCaptureGetter native regexp.js:363",0x2e87cc519288,
  code-creation,LazyCompile,0x127fc3e17000,668," native regexp.js:364",0x2e87cc519340,
  code-creation,LazyCompile,0x127fc3e172a0,2304,"SetUpRegExp native regexp.js:403",0x2e87cc519488,
  code-creation,LazyCompile,0x127fc3e17ba0,292,"SetUpRegExp.a native regexp.js:422",0x2e87cc519540,
  code-creation,LazyCompile,0x127fc3e17ce0,256,"SetUpRegExp.c native regexp.js:426",0x2e87cc519658,</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript ParseTrees]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/27/javascript-parsetrees/"/>
    <updated>2013-02-27T20:22:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/27/javascript-parsetrees</id>
    <content type="html"><![CDATA[<p>I've been experimenting with the rkelly Ruby gem to help me explore the JavaScript parse tree. It is really fascinating, and I can see
myself spending a lot of time spelunking through the language. Here is a simple example using the gem to iterate over each node in the
parse tree and print out its type. Stay tuned, more to come!</p>

<p>.. code-block:: ruby</p>

<p>  require 'rubygems'
  require 'rkelly'
  parser = RKelly::Parser.new
  src = &lt;&lt;EOF
  // Create scrollLeft and scrollTop methods
  jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {</p>

<pre><code>var top = "pageYOffset" === prop;

jQuery.fn[ method ] = function( val ) {
  return jQuery.access( this, function( elem, method, val ) {
    var win = getWindow( elem );

    if ( val === undefined ) {
      return win ? win[ prop ] : elem[ method ];
    }

    if ( win ) {
      win.scrollTo(
        !top ? val : window.pageXOffset,
        top ? val : window.pageYOffset
      );

    } else {
      elem[ method ] = val;
    }
  }, method, val, arguments.length, null );
};
</code></pre>

<p>  });</p>

<p>  function getWindow( elem ) {</p>

<pre><code>return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
</code></pre>

<p>  }
  EOF
  ast = parser.parse(src)</p>

<p>  =begin
  Outputs something like this as it traverses the parseTree
  RKelly::Nodes::SourceElementsNode
  RKelly::Nodes::ExpressionStatementNode
  RKelly::Nodes::FunctionCallNode
  RKelly::Nodes::DotAccessorNode
  RKelly::Nodes::ResolveNode
  RKelly::Nodes::ArgumentsNode
  RKelly::Nodes::ObjectLiteralNode
  RKelly::Nodes::PropertyNode
  ...
  =end</p>

<p>  ast.each do |node|</p>

<pre><code>puts node.class
</code></pre>

<p>  end</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Closure]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/25/getting-closure/"/>
    <updated>2013-02-25T15:21:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/25/getting-closure</id>
    <content type="html"><![CDATA[<p>Understanding the Dark Arts of JavaScript Closures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>

<pre><code> "No matter where you go, there you are." 
 - Buckaroo Banzai
</code></pre>

<p>The purpose of this post is to explain how closures work in plain english, and to give a few compelling examples where the use of closures really improve
the quality of your code.</p>

<p>Like many others I am a self-taught programmer, and little over a decade ago I was also a freshly minted Creative Director working in Los Angels. I was employed
by a major footwear brand, and had inherited a team of very bright and technically gifted programmers. I felt that I needed to learn enough code to speak
intelligently to them. I didn't want to propose a feature that wasn't possible, and more importantly I wanted to understand the promise and the problems
inherent in the medium we were building within. More generally though, I am just a very curious person who likes to learn. Once I started to pull that tread
the world of programming began to unwind for me. Now years later, here I sit writing about the internals of JavaScript.</p>

<p>Being that my computer science education has been ad-hoc there are many core concepts in JavaScript (and programming in general) that I wanted to understand
better. My hypothesis is that there are others like me who have been using and abusing JavaScript for years. For this reason I decided to write on closures an
often used but equally often misunderstood concept in JavaScript. Closures are important for a variety of reasons:</p>

<ol>
<li>They are both a feature and a philosophy that once understood makes many other concepts (e.g. data binding, promise objects) in JavaScript easier.</li>
<li>They are one of the most powerful internals of the language, which many other so-called <em>real</em> languages don't support.</li>
<li>They are where JavaScript is trending due to the rise in popularity of asynchronous execution.</li>
</ol>


<p>For all the potential benefits that closures offer, there is a <em>black magic</em> quality to them that can make them hard to understand. Let's start with a
definition, <strong>A closure is the act of binding all free variables, and functions into a closed expression, that persist beyond the lexical scope from which they
were created.</strong> While this is a succinct definition it is pretty impenetrable for the uninitiated; let's dig deeper.</p>

<p>The Straight Dope On Scope
~~~~~~~~~~~~~~~~~~~~~~~~~~
Before we can truly understand closures we must take a step back and look at how scope works in JavaScript. When reading about JavaScript periodically
writers will make reference to lexical scope, or the current and/or executing scope. Lexical scope simply means that where a statement is placed within the
body of the script is important and effects how it can be accessed, and what in turn it has access to. In JavaScript unlike other languages the only way to
create a new scope is through a function invocation [1]_. This is what programmers mean when they say JavaScript has function level scoping. This form of
scoping may be anti-intuitive to programmers coming from languages that support block-level scoping e.g. Ruby.</p>

<p>The following example demonstrates lexical scope:</p>

<p>.. code-block:: javascript</p>

<p>  // Free Variable
  var iAmFree = 'Free to be me!';</p>

<p>  function canHazAccess(notFree){</p>

<pre><code>var notSoFree = "i am bound to this scope";

// =&gt; "Free to be me!"
console.log(iAmFree);
</code></pre>

<p>  }</p>

<p>  // => ReferenceError: notSoFree is not defined
  console.log(notSoFree)</p>

<p>  canHazAccess();</p>

<p>As you can see the function declaration <em>canHazAccess()</em> can reference the <em>iAmFree</em> variable; this is because the variable belongs to the enclosing scope. The
<em>iAmFree</em> variable is an example of what in JavaScript is called a <strong>free variable</strong> [2]_. Free variables are any non-local variable which the function
body has access to. To qualify as a free variable it must be defined outside the function body and not be passed as a function argument.</p>

<p>Conversely, we see that referencing <em>notSoFree</em> from the enclosing scope produces an error. This is because at the point at which this variable
was defined it was inside a new lexical scope (remember function invocation creates a new scope).</p>

<p>Put another way, <strong>function level scopes act like one-way mirrors; they let elements inside the function body spy on variables in the outer scope, while they
remain hidden.</strong> As we'll see below closures short-circuit this relationship, and provide a mechanism whereby the inner scopes internals can
be accessed by the outer scope.</p>

<p>Thisunderstandings
~~~~~~~~~~~~~~~~~~</p>

<p>One feature of scopes, that routinely throw developers off (even seasoned ones) is the use of the <em>this</em> keyword as it pertains to the lexical
scope. In JavaScript the <strong>this keyword always refers to the owner of scope from which it is executing</strong>. Misunderstanding how <em>this</em> works can
cause all sorts of weird errors where a developer assumes they are accessing a particular scope but are actually using another. Here is how this might
happen:</p>

<p>.. code-block:: javascript</p>

<p>  var Car, tesla;</p>

<p>  Car = function() {</p>

<pre><code>this.start = function() {
  console.log("car started");
};

this.turnKey = function() {
  var carKey = document.getElementById('car_key');
  carKey.onclick = function(event) {
    this.start();
  };
};
return this;
</code></pre>

<p>  };
  tesla = new Car();</p>

<p>  // Once a user click's the #carKey element they will see "Uncaught TypeError: Object  has no method 'start'"
  tesla.turnKey();</p>

<p>The developer who wrote this was headed in the right direction, but ultimately a <em>thisunderstanding</em> forced them off the rails. They correctly bound
the click event to the <em>car_key</em> DOM element. However, they assumed that nesting the click binding inside the car class would give the DOM element a reference
to the car's <em>this</em> context. The approach is intuitive and <em>looks legit</em>, especially based on what we know about free variables and lexical scope. Unfortunately,
it's hopelessly borked; because as we learned earlier a new scope is created each time a function is invoked. Once the onclick event fired <em>this</em> now
referred to the DOM element not the car class.</p>

<p>Developers sometimes get around this scoping confusion by assigning <em>this</em> to a local free variable (e.g. that, _this, self, me). Here is the previous method
rewritten to use a local free variable instead of <em>this</em>.</p>

<p>.. code-block:: javascript</p>

<p>  var Car, tesla;</p>

<p>  Car = function() {</p>

<pre><code>this.start = function() {
  console.log("car started");
};

this.turnKey = function() {
  var that = this;
  var carKey = document.getElementById('carKey');
  carKey.onclick = function(event) {
    that.start();
  };
};
return this;
</code></pre>

<p>  };
  tesla = new Car();</p>

<p>  // Once a user click's the #carKey element they will see "car started"
  tesla.turnKey();</p>

<p>Because <em>that</em> is a free variable, it won't be redefined when the onclick event is triggered. Instead it remains as a pointer to the previous <em>this</em> context.
Technically, this solves the problem, and I am going to resist the urge of calling this an anti-pattern (for now). I have used this technique thousands of
times over the years. However, it always <em>felt</em> like a hack, and fortunately, closures can help us marshall scopes in a much more elegant way.</p>

<p>My First Closure
~~~~~~~~~~~~~~~~</p>

<p>In it's most basic form a closure is simply an outer function that returns an inner function. Doing this creates a mechanism to return an enclosed scope on
demand. Here is a simple closure:</p>

<p>.. code-block:: javascript</p>

<p>  function outer(name) {</p>

<pre><code>var hello = "hi",
inner;

return inner = function() {
  return hello + " " + name;
}
</code></pre>

<p>  }</p>

<p>  // Create and use the closure
  var name = outer("mark")();</p>

<p>  // => 'hi mark'
  console.log(name);</p>

<p>In this example you can see that the local variable <em>hello</em> can be used in the return statement of the inner function. At the point of execution <em>hello</em> is a
free variable belonging to the enclosing scope. This example borders on meaninglessness though; lets look at a slightly more complex closure:</p>

<p>.. code-block:: javascript</p>

<p>  var car;
  function carFactory(kind) {</p>

<pre><code>var wheelCount, start;
wheelCount = 4;
start = function() {
  console.log('started with ' + wheelCount + ' wheels.');
};

// Closure created here.
return (function() {
  return {
    make: kind,
    wheels: wheelCount,
    startEngine: start
  };
}());
</code></pre>

<p>  }</p>

<p>  car = carFactory('Tesla');</p>

<p>  // => Tesla
  console.log(car.make);</p>

<p>  // => started with 4 wheels.
  car.startEngine();</p>

<p>Why Use Closures
~~~~~~~~~~~~~~~~
Now that we know what closures are, let's look at some use cases on where they can elegantly solve common problems in JavaScript.</p>

<ul>
<li><p><strong>Object Factories</strong></p>

<p>The previous closure implements what is commonly known as the Factory Pattern [3]_. In keeping with a Factory Pattern the internals of the factory can be
quite complex but are abstracted away in part thanks to the closure. This highlights one of the best features of closures which is their ability to
hide state. JavaScript doesn't have the concept of private or protected contexts, but using closures give us a good way to emulate some level of privacy.</p></li>
<li><p><strong>Create A Binding Proxy</strong></p>

<p>As promised lets revisit the Car class we wrote earlier. We solved the scoping problem by assigning the outer function's <em>this</em> reference to a <em>that</em> free
variable. Instead of that approach we'll solve it through the use of closures. First we create a reusable closure function called <em>proxy</em>, which takes
a function and a context and returns a new function with the supplied context applied. Then we wrap the onclick function with our <em>proxy</em> and pass in the <em>this</em>
that references the current instance of the <em>Car</em> class. Coincidentally, this is a simplified version of what jQuery does in their own proxy function [4]_.</p>

<p>.. code-block:: javascript</p>

<p>  var Car, proxy, tesla;</p>

<p>  Car = function() {</p>

<pre><code>this.start = function() {
  return console.log("car started");
};
this.turnKey = function() {
  var carKey;
  carKey = document.getElementById("carKey");
  carKey.onclick = proxy(function(event) {
    this.start();
  }, this);
};
return this;
</code></pre>

<p>  };</p>

<p>  // Use a closure to bind the outer scope's reference to this into the newly created inner scope.
  proxy = function(callback, self) {</p>

<pre><code>return function() {
  return callback.apply(self, arguments);
};
</code></pre>

<p>  };</p>

<p>  tesla = new Car();</p>

<p>  // Once a user click's the #carKey element they will see "car started"
  tesla.turnKey();</p></li>
<li><p><strong>Contextually Aware DOM Manipulation</strong></p>

<p>This example comes from directly from Juriy Zaytsev's excellent article "Use Cases for JavaScript Closures" [5]_ . His example code demonstrates how to use a
closure to ensure a DOM element has a unique ID. The larger takeaway is that you can use closures as a way to maintain internal states about your program in
an encapsulated manner.</p>

<p>.. code-block:: javascript</p>

<p>  var getUniqueId = (function() {</p>

<pre><code>var id = 0;
return function(element) {
  if (!element.id) {
    element.id = 'generated-uid-' + id++;
  }
  return element.id;
};
</code></pre>

<p>  })();</p>

<p>  var elementWithId = document.createElement('p');
  elementWithId.id = 'foo-bar';
  var elementWithoutId = document.createElement('p');</p>

<p>  // => 'foo-bar'
  getUniqueId(elementWithId);</p>

<p>  // => 'generated-id-0'
  getUniqueId(elementWithoutId);</p></li>
<li><p><strong>Singleton Module Pattern</strong></p>

<p>Modules are used to encapsulate and organize related code together under one roof. Using modules keeps your codebase cleaner, easier to test, and reuse.
Attribution for the Module Pattern is typically given to Richard Conford [6]<em>, though a number of people most notably Douglas Crockford are responsible for
popularizing it. The Singleton Module is a flavor that restricts more than one instance of the object from existing. It is very useful for instances where
you want several objects to share a resource. A much more in depth example of the Singleton Module can be found here [7]</em>, but for now consider the following
example:</p>

<p>.. code-block:: javascript</p>

<p>  // Create a closure
  var SecretStore = (function() {</p>

<pre><code>var data, secret, newSecret;

// Emulation of a private variables and functions
data = 'secret';
secret = function() {
  return data;
}
newSecret = function(newValue) {
  data = newValue;
  return secret();
}

// Return an object literal which is the only way to access the private functions and variables
return {
  getSecret: secret,
  setSecret: newSecret,
};
</code></pre>

<p>  })();</p>

<p>  var secret = SecretStore;</p>

<p>  // => "secret"
  console.log(secret.getSecret());</p>

<p>  // => "foo"
  console.log(secret.setSecret("foo"));</p>

<p>  // => "foo"
  console.log(secret.getSecret());</p>

<p>  var secret2 = SecretStore;</p>

<p>  // => "foo"
  console.log(secret2.getSecret());</p></li>
</ul>


<p>TLDR Takeaways
~~~~~~~~~~~~~~</p>

<ol>
<li><strong>Lexical scope gives importance to where code is located within the script body.</strong></li>
<li><strong>Free variables are any non-local variable which the function body has access to.</strong></li>
<li><strong>The only way for new scopes to be created in JavaScript is through function invocation.</strong></li>
<li><strong>The <em>this</em> keyword always refers to the owner of scope from which it is executing.</strong></li>
<li><strong>A closure allows a function to access variables outside of its lexical scope.</strong></li>
</ol>


<p>.. [1] http://howtonode.org/what-is-this
.. [2] http://en.wikipedia.org/wiki/Free_variable
.. [3] http://en.wikipedia.org/wiki/Factory_method_pattern
.. [4] https://github.com/jquery/jquery/blob/master/src/core.js#L685
.. [5] http://msdn.microsoft.com/en-us/magazine/ff696765.aspx
.. [6] http://groups.google.com/group/comp.lang.javascript/msg/9f58bd11bd67d937
.. [7] http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Jigs]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/18/javascript-jigs/"/>
    <updated>2013-02-18T09:06:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/18/javascript-jigs</id>
    <content type="html"><![CDATA[<p>In the excellent book "The Pragmatic Programmer: From Journeyman to Master" Hunt and Thomas use the metaphor of a wood worker's jig to describe
how a smart programmer reduces the repetitive nature of coding by creating reusable templates or code generators:</p>

<pre><code>"When woodworkers are faced with the task of producing the same thing over and over, they cheat. They build themselves a jig or a template.
If they get the jig right once, they can reproduce a piece of work time after time. The jig takes away complexity and reduces the chances
of making mistakes, leaving the craftsman free to concentrate on quality."
</code></pre>

<p>To be a jig the solution is highly specific and good for one task, for example making a complex cut. At first you might
want to conflate jigs and design patterns together, because they are both reusable solutions to a problem. Jigs are precise where design
patterns are generalized. While Hunt and Thomas said jigs are generators, I will use them in the context of helpers, friendly little functions
or classes that do one thing well. Many of the most popular JavaScript libraries started as a collection of jigs. Prototype and JQuery for
example, were initially just a collection of reusable snippets that acted like speed-boosts, and shortcuts for discrete problems.</p>

<p>What follows are a collection of jigs that are useful in modern JavaScript applications.</p>

<p>Self Executing Functions
~~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>The immediately invoked function expression (IIFE) is one jig you will see various libraries and frameworks use repeatedly. In its most basic form it can be
written in a couple of ways</p>

<p>.. code-block:: javascript</p>

<p>  ;(function(){</p>

<pre><code>  ...
</code></pre>

<p>  })();</p>

<p>  ;!function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;-function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;+function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;~function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  // Not Recommended
  ;void function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  // Not Recommended
  ;delete function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>The beauty of the IIFE is that it uses a unary expression to coerce a function declaration, which would normally need to be explicitly called
into a function expression that can self-execute. Behind the scenes JavaScript is running a unary operation on the function declaration, the
result of that operation is the function expression, which is immediately invoked with the trailing parentheses "()". Besides being elegant code
the IIFE also affords the following:</p>

<ul>
<li>It provides a closure which prevents naming conflicts</li>
<li>It provides elegant block scoping</li>
<li>It prevents pollution of the global namespace.</li>
<li>It promotes the developer to think in terms of modular code.</li>
</ul>


<p>One other point worth mentioning is the use of the semicolon prepending the statement. Adding this provides a bit of defensive programming
against other malformed modules that might have a trailing semicolon. If this were just a function declaration it would be absorbed into the
preceding module. This can often occur when multiple scripts are concatenated together as part of a deploy process. It is highly recommended
that you follow this convention to protect yourself against mystery bugs in production.</p>

<p>Modules
~~~~~~~</p>

<p>Modules are very common is many programming languages, though JavaScript doesn't have a native representation for them. As such other developers
have developed a spec for encapsulating your code inside a reusable module. The following code is based off an example in the "Principles of
Writing Consistent, Idiomatic JavaScript" [1]_.</p>

<p>There are a couple of elements that should be called out in this jig:</p>

<ul>
<li>We see two different examples of the self executing function jig being used. This is to ensure proper closure around the module itself and the
initializer function that adds it to the global namespace.</li>
<li>Invoking this function returns an object with a bound reference to the private variable "data". This allows the developer to enforce
the use of getters and setters for access to the data variable.</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  ;!function(global) {</p>

<pre><code>var Module = (function() {

  // Mostly Private Variable
  var data = 'secret';

  return {

    bool: true,
    string: 'a string',
    array: [1, 2, 3, 4],
    object: {
      lang: "en-Us"
    },
    getData: function() {
      return data;
    },
    setData: function(value) {
      return (data = value);
    }
  };
})();

// expose our module to the global object
global.Module = Module;
</code></pre>

<p>  }(this);</p>

<p>safeEval
~~~~~~~~</p>

<p>The eval function and its siblings setTimeout, setInterval and Function all have access to the JavaScript compiler, which means it is a bit
like running with scissors. Since eval typically does more harm than good people try to work around it as much as possible. This jig does just
that giving you eval like features without calling the function.</p>

<p>.. code-block:: javascript</p>

<p>  // A string representation of an a object similar to what you might get with JSON.
  var dataString = '{"foo":"bar"}';</p>

<p>  ;!function(global, data){</p>

<pre><code>  // the variable name provided is replaced with the evaluated code.
  global[data] = new Function("return" + global[data])() 
</code></pre>

<p>  }(this, "dataString");</p>

<p>  // dataString is now Object {foo: "bar"}</p>

<p>PubSub
~~~~~~</p>

<p>PubSub is short for a publish-subscribe message system, where objects ask to receive messages that are broadcast by publishers. The main
advantage of PubSub is that the subscribers are loosely coupled allowing just about any object to publish and subscribe to messages. PubSub
systems also have been proven to scale much nicer that tightly coupled client / server paradigms. This implementation of PubSub was written
by Ben Alman and can be download from his Github account [2]_. Let's take a look at this jig in detail. Again, the first thing you should
notice is that this jig uses the IIFE jig too (see a pattern yet?). This jig does depend on jQuery for access to the "on","off", and "trigger"
functions. This jig stores an internal list of subscribers as keys of the internal object "o". When a message is broadcast all the subscribers
have the arguments supplied by the publisher transferred to them.</p>

<p>.. code-block:: javascript</p>

<p>  ;(function($) {</p>

<pre><code>var o = $({});

$.subscribe = function() {
  o.on.apply(o, arguments);
};

$.unsubscribe = function() {
  o.off.apply(o, arguments);
};

$.publish = function() {
  o.trigger.apply(o, arguments);
};
</code></pre>

<p>  }(jQuery));</p>

<p>  // Usage Examples
  // Creates a "named" logging function.</p>

<p>  function createLogger(name) {</p>

<pre><code>return function(event, a, b) {

  // Skip the first argument (event object) but log the name and other args.
  console.log(name, a, b);
};
</code></pre>

<p>  }</p>

<p>  // Subscribe to the "foo" topic (bind to the "foo" event, no namespace).
  $.subscribe('foo', createLogger('foo'));</p>

<p>  // Subscribe to the "foo.bar" topic (bind to the "foo" event, "bar" namespace).
  $.subscribe('foo.bar', createLogger('foo.bar'));</p>

<p>  /<em>
   * logs:
   * foo 1 2
   * foo.bar 1 2
   * foo.baz 1 2
   </em>/
  $.publish('foo', [1, 2]);</p>

<p>  /<em>
   * logs:
   * foo.bar 3 4
   </em>/
  $.publish('foo.bar', [3, 4]);</p>

<p>Your Jigs Go Here
~~~~~~~~~~~~~~~~~
Please send me your favorite jigs. I would love to expand this post with more great Jigs.</p>

<p>Footnotes
~~~~~~~~~</p>

<p>.. [1] https://github.com/rwldrn/idiomatic.js/
.. [2] https://github.com/cowboy/jquery-tiny-pubsub</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functions Explained]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/15/functions-explained/"/>
    <updated>2013-02-15T12:10:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/15/functions-explained</id>
    <content type="html"><![CDATA[<p>A Deep Dive into JavaScript Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>Based on my readership I have to assume most of you are familiar with JavaScript already. Therefore, it may seem odd to include a post on functions. After all, they are
one of the most rudimentary components of JavaScript. My assertion is this, just as a person can speak a language without the ability to read
or write it, so too can developers use functions in JavaScript and yet be blissfully unaware of their complexities.</p>

<p>Typically developers only become aware of the specifics of functions when something they wrote explodes in their face. My goal in this section
is to expose the intricacies of JavaScript functions to you, which will hopefully save you from having to pull syntactic shrapnel from your
codebase.</p>

<p>A word of caution before we begin; JavaScript is only as good as its interpreter. While the concepts we'll consider are well-covered in
the language spec, it does not mean that all runtime environments will work the same way. In other words your milage may vary. This section will
discuss common misconceptions of JavaScript functions, and the silent bugs they introduce. However, debugging functions in detail is not
covered. Fortunately, debugging has been documented by others in the JavaScript community especially in Juriy Zaytsev's excellent article "Named
Function Expressions Demystified" [1]_.</p>

<p>Blocks in JavaScript
~~~~~~~~~~~~~~~~~~~~</p>

<p>Before we can understand functions in JavaScript we have to understand blocks. JavaScript blocks are nothing more than statements grouped
together. Blocks start with a left curly bracket "{" and end with a right one "}". Simply put, <strong>blocks allow statements inside the brackets
to be executed together</strong>. Blocks form the most basic control structure in JavaScript. The following are a few examples of how blocks in
JavaScript:</p>

<p>.. code-block:: javascript</p>

<p>  // Block as an anonymous self-executing function
  ;!function () {</p>

<pre><code>  var triumph = false,
      cake = false,
      satisfaction = 0,
      isLie,
      note;

  // Block used as part of function expression
  var isLie = function (val) {
      return val === false;
  }

  // Block used as part of a conditional statement
  if (isLie(cake)) {
      triumph = true;
      makeNote('huge success');
      satisfaction += 10;
  }

  // Block used as part of a function declaration
  function makeNote(message) {
      note = message;
  }
</code></pre>

<p>  }();</p>

<p>As we saw above, functions are essentially <em>named blocks</em>, which the developer can invoke on demand. This is easy to demonstrate:</p>

<p>.. code-block:: javascript</p>

<p>  // The inline conditional block statement is executed only once per cycle.
  if (isLie(cake)) {</p>

<pre><code>  ...
</code></pre>

<p>  }</p>

<p>  function makeNote(message) {</p>

<pre><code>  ...
</code></pre>

<p>  }</p>

<p>  // The function declaration is executed as many times as it is called.
  makeNote("Moderate Success");
  makeNote("Huge Success");</p>

<p>Function Arguments
~~~~~~~~~~~~~~~~~~</p>

<p>Functions like control flow statements (if, for, while etc.) can be initialized by passing arguments into the function body. In JavaScript
variables are either a <strong>complex type</strong> (e.g. Object, Array) or a <strong>primitive type</strong> (e.g. String, Integer). When a complex object is supplied
as an argument it is <strong>passed by reference</strong> to the function body. Instead of sending a copy of the variable, JavaScript sends a pointer to its
location in memory. Conversely, when passing a primitive type to a function JavaScript <strong>passes by value</strong>. This difference can lead to subtle bugs
because conceptually we often treat functions as a black box, and assume they can only effect the enclosing scope by returning a variable.
With pass by reference, the argument object is modified even though it may not returned by the function. Pass by reference and pass by value
are demonstrated below:</p>

<p>.. code-block:: javascript</p>

<p>  var object = {</p>

<pre><code>  'foo': 'bar'
</code></pre>

<p>  },
  num = 1;</p>

<p>  // Passed by reference
  ;!function(obj) {</p>

<pre><code>  obj.foo = 'baz';
</code></pre>

<p>  }(object);</p>

<p>  // => Object {foo: "baz"}
  console.log(object);</p>

<p>  // Passed by value;
  ;!function(num) {</p>

<pre><code>  num = 2;
</code></pre>

<p>  }(num);</p>

<p>  // => 1
  console.log(num);</p>

<p>Function Types
~~~~~~~~~~~~~~~</p>

<p>Now that we have a better understanding of blocks, and arguments lets dive deeper into <strong>Function Declaration</strong> and <strong>Function Expression</strong>,
the two types of functions used in JavaScript. To the casual reader the two appear very similar:</p>

<p>.. code-block:: javascript</p>

<p>  // Function Declaration
  function isLie(cake){</p>

<pre><code>  return cake === true;
</code></pre>

<p>  }</p>

<p>  // Function Expression
  var isLie = function(cake){</p>

<pre><code>  return cake === true;
</code></pre>

<p>  }</p>

<p>The only real difference between the two, is when they are evaluated. A function declaration can be accessed by the interpreter as it is being
parsed. The function expression on the other hand is part of an assignment expression, which prevents JavaScript from evaluating it until the
program has completed the assignment. This difference may seem minor, but implications are huge; consider the following example:</p>

<p>.. code-block:: javascript</p>

<p>  // => Hi, I'm a function declaration!
  declaration();</p>

<p>  function declaration() {</p>

<pre><code>  console.log("Hi, I'm a function declaration!");
</code></pre>

<p>  }</p>

<p>  // => Uncaught TypeError: undefined is not a function
  expression();</p>

<p>  var expression = function () {</p>

<pre><code>  console.log("Hi, I'm a function expression!");
</code></pre>

<p>  }</p>

<p>As you can see in the previous example the <em>expression</em> function threw an exception when it was invoked, but the <em>declaration</em> function
executed just fine. This exception gets to the heart of the difference between declaration and expression functions. JavaScript <em>knows</em>
about declaration function and can parse it before the program executes. Therefore, it doesn't matter if the program invokes the function
before it is defined. This is because behind the scenes JavaScript has <em>hoisted</em> the function to the top of the current scope. The function
expression is not evaluated until it is assigned to a variable; therefore it is still <em>undefined</em> when invoked. This is why good code style is
to define all variables at the top of the current scope. Had we done this then our script would visually match what JavaScript is doing during
parsetime.</p>

<p>The concept to take away is that <strong>during parsetime JavaScript moves all function declarations to the top of the current scope</strong>. This is why
it doesn't matter where declarative functions appear in the script body.</p>

<p>To further explore the distinctions between declarations and expressions, consider the following:</p>

<p>.. code-block:: javascript</p>

<p>  function sayHi() {</p>

<pre><code>  console.log("hi");
</code></pre>

<p>  }</p>

<p>  var hi = function sayHi() {</p>

<pre><code>  console.log("hello");
</code></pre>

<p>  }</p>

<p>  // => "hello"
  hi();</p>

<p>  // => 'hi'
  sayHi();</p>

<p>Casually reading this code, one might assume that the declaration function would get clobbered because it function expression has an identical
name. However, since the second function is part of an assignment expression it is given its own scope, and JavaScript treats them as seperate
entities. To make things even more confusing look at this example:</p>

<p>.. code-block:: javascript</p>

<p>  var sayHo</p>

<p>  // => function
  console.log(typeof (sayHey))</p>

<p>  // => undefined
  console.log(typeof (sayHo))</p>

<p>  if (true) {</p>

<pre><code>  function sayHey() {
      console.log("hey");
  }

  sayHo = function sayHo() {
      console.log("ho");
  }
</code></pre>

<p>  } else {</p>

<pre><code>  function sayHey() {
      console.log("no");
  }

  sayHo = function sayHo() {
      console.log("no");
  }
</code></pre>

<p>  }</p>

<p>  // => no
  sayHey();</p>

<p>  // => ho
  sayHo();</p>

<p>In the previous example we saw that functions of the same name were considered different if one was an expression and the other was a
declaration. In this example we are attempting to conditionally define the function based on how the program executes. Reading the script's
control flow you'd expect <em>sayHey</em> to return "hey" since the conditional statement evaluates true. Instead it returns "no", meaning the second
version of the <em>sayHey</em> function clobbered the first. Even more confusing is that the <em>sayHo</em> function behaves the opposite way! Again, the
difference comes down to parsetime versus runtime.</p>

<p>We already learned that when JavaScript parses the script it collects all of the function declarations and hoists them to the top of the current
scope. When this happens it clobbers the first version of <em>sayHey</em> with the second because they exist in the same scope. This explains why
it returns "no." We also know that function expressions are ignored by the parser until the assignment process completes. Assignment happens
during runtime, which is also when the conditional statement is evaluated. That explains why the <em>sayHo</em> function was able to be conditionally
defined. The key to remember here is that <strong>function declarations can not be conditionally defined. If you need conditional definition use a function expression</strong>.
Furthermore, <strong>function declarations should NEVER be made inside a control flow statement</strong>, due to the different ways interpreters handle it.</p>

<p>Function Scopes
~~~~~~~~~~~~~~~</p>

<p>Unlike many other languages which are scoped to the block, JavaScript is scoped to the function. In Ruby (version 1.9.+) you can write this:</p>

<p>.. code-block:: javascript</p>

<p>  x = 20
  10.times do |x|</p>

<pre><code># =&gt; 0..9
puts x
</code></pre>

<p>  end</p>

<p>  # => 20
  puts x</p>

<p>What this demonstrates is that each block gets its own scope. Conversely, if we wrote similar code in JavaScript:</p>

<p>.. code-block:: javascript</p>

<p>  var x = 20;</p>

<p>  // Functions have their own scope
  ;!function() {</p>

<pre><code>  var x = "foo";

  // =&gt; "foo"
  console.log(x);
</code></pre>

<p>  }();</p>

<p>  // => 20
  console.log(x);</p>

<p>  for (x = 0; x &lt; 10; x++) {</p>

<pre><code>  // =&gt; 0..9
  console.log(x);
</code></pre>

<p>  }</p>

<p>  // => 10
  console.log(x);</p>

<p>In JavaScript <em>x</em> is available inside the for loop, because as a control statement it belongs to the enclosing scope. This is not intuitive to
many developers used to block level scope. JavaScript handles the need of block level scope at least partially through the use of closures
which we'll discuss later.</p>

<p>Debugging Functions
~~~~~~~~~~~~~~~~~~~</p>

<p>Before we wrap this topic up, lets briefly touch on debugging functions. In JavaScript naming a function expression is completely optional;
so why do it? The answer is to aid the debugging process. Named function expressions have access to their name within the newly defined scope,
but not in the enclosing scope. Without a name their anonymous nature can make them feel a bit like ghosts in the machine when it comes to
debugging.</p>

<p>.. code-block:: javascript</p>

<p>  var namedFunction = function named() {</p>

<pre><code>  // =&gt; function
  console.log(typeof(named));
</code></pre>

<p>  }
  namedFunction();</p>

<p>  // => undefined
  console.log(typeof(named));</p>

<p>Nameless function expressions will be displayed in the stack trace as "(anonymous function)" or something similar. Naming your function
expression gives you clarity when trying to unwind an exception whose call stack may feel miles long.</p>

<p>.. code-block:: javascript</p>

<p>  /<em>
   * It is much harder to debug anonymous function expressions
   * Uncaught boom
   *    - (anonymous function)
   *    - window.onload
   </em>/
  ;!function(){</p>

<pre><code>  throw("boom");
</code></pre>

<p>  }();</p>

<p>  /<em>
   * Naming your function expressions give you a place to start looking when debuggin.
   * Uncaught boom
   *    - goBoom
   *    - window.onload
   </em>/
  ;!function goBoom() {</p>

<pre><code>  throw("boom")
</code></pre>

<p>  }();</p>

<p>.. [1] http://kangax.github.com/nfe/</p>
]]></content>
  </entry>
  
</feed>
